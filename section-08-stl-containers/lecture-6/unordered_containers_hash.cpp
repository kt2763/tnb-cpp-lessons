/*
 * Lecture 6: Unordered Containers (C++11) - ハッシュテーブル
 * 
 * unordered_map/set は C++11 で導入されたハッシュテーブルベースのコンテナです。
 * 平均的にO(1)の高速アクセスが可能で、大量データの高速検索や
 * リアルタイムゲームでのパフォーマンス向上に重要です。
 */

#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <vector>
#include <chrono>
#include <random>

// プレイヤーデータ
struct Player
{
    std::string name;
    int level;
    int score;
    
    Player(const std::string& n = \"\", int l = 1, int s = 0)
        : name(n), level(l), score(s)
    {
    }\n};\n\n// ゲーム内リソース\nstruct GameResource\n{\n    std::string path;\n    size_t size;\n    bool loaded;\n    \n    GameResource(const std::string& p = \"\", size_t s = 0, bool l = false)\n        : path(p), size(s), loaded(l)\n    {\n    }\n};\n\n// カスタムハッシュ関数の例\nstruct PlayerHash\n{\n    size_t operator()(const Player& p) const\n    {\n        // 文字列のハッシュと整数のハッシュを組み合わせ\n        std::hash<std::string> strHash;\n        std::hash<int> intHash;\n        \n        return strHash(p.name) ^ (intHash(p.level) << 1) ^ (intHash(p.score) << 2);\n    }\n};\n\n// カスタム等価比較\nstruct PlayerEqual\n{\n    bool operator()(const Player& a, const Player& b) const\n    {\n        return a.name == b.name && a.level == b.level && a.score == b.score;\n    }\n};\n\nint main()\n{\n    // 1. unordered_map の基本使用法\n    std::cout << \"=== unordered_map - 基本操作 ===\\n\";\n    \n    std::unordered_map<std::string, int> playerScores;\n    \n    // 要素の挿入\n    playerScores[\"勇者アキラ\"] = 2500;\n    playerScores[\"魔法使いユミ\"] = 3000;\n    playerScores[\"戦士タロウ\"] = 1800;\n    playerScores.emplace(\"盗賊サトシ\", 2200);\n    \n    std::cout << \"プレイヤースコア (順序は不定):\\n\";\n    for (const auto& [name, score] : playerScores)\n    {\n        std::cout << \"  \" << name << \": \" << score << \"\\n\";\n    }\n    \n    // 高速検索\n    std::string searchName = \"魔法使いユミ\";\n    auto it = playerScores.find(searchName);\n    if (it != playerScores.end())\n    {\n        std::cout << \"\\n\" << searchName << \"のスコア: \" << it->second << \"\\n\";\n    }\n    \n    // 2. リソースキャッシュシステム\n    std::cout << \"\\n=== リソースキャッシュシステム ===\\n\";\n    \n    std::unordered_map<std::string, GameResource> resourceCache;\n    \n    // リソースをキャッシュに追加\n    resourceCache[\"player_texture\"] = GameResource(\"assets/player.png\", 1024000, true);\n    resourceCache[\"enemy_model\"] = GameResource(\"assets/enemy.obj\", 2048000, true);\n    resourceCache[\"background_music\"] = GameResource(\"assets/bgm.ogg\", 5120000, false);\n    resourceCache[\"sound_effect\"] = GameResource(\"assets/attack.wav\", 256000, true);\n    \n    // リソース検索関数\n    auto findResource = [&](const std::string& name) -> GameResource*\n    {\n        auto it = resourceCache.find(name);\n        return (it != resourceCache.end()) ? &it->second : nullptr;\n    };\n    \n    // リソースの検索と使用\n    if (auto* resource = findResource(\"player_texture\"))\n    {\n        std::cout << \"リソース発見: \" << resource->path \n                  << \" (サイズ: \" << resource->size << \" bytes, \"\n                  << (resource->loaded ? \"ロード済み\" : \"未ロード\") << \")\\n\";\n    }\n    \n    // キャッシュ統計\n    size_t totalSize = 0;\n    int loadedCount = 0;\n    \n    for (const auto& [name, resource] : resourceCache)\n    {\n        totalSize += resource.size;\n        if (resource.loaded)\n        {\n            ++loadedCount;\n        }\n    }\n    \n    std::cout << \"\\nキャッシュ統計:\\n\";\n    std::cout << \"  総リソース数: \" << resourceCache.size() << \"\\n\";\n    std::cout << \"  ロード済み: \" << loadedCount << \"\\n\";\n    std::cout << \"  総サイズ: \" << totalSize << \" bytes\\n\";\n    \n    // 3. unordered_set - 高速な重複チェック\n    std::cout << \"\\n=== unordered_set - 高速重複チェック ===\\n\";\n    \n    std::unordered_set<std::string> activePlayerIDs;\n    \n    // オンラインプレイヤーの管理\n    activePlayerIDs.insert(\"player_001\");\n    activePlayerIDs.insert(\"player_002\");\n    activePlayerIDs.insert(\"player_003\");\n    activePlayerIDs.insert(\"player_001\");  // 重複は無視\n    \n    std::cout << \"アクティブプレイヤー数: \" << activePlayerIDs.size() << \"\\n\";\n    \n    // プレイヤーがオンラインかチェック\n    std::string checkID = \"player_002\";\n    if (activePlayerIDs.count(checkID) > 0)\n    {\n        std::cout << checkID << \" はオンラインです\\n\";\n    }\n    \n    // バッチ処理：複数プレイヤーのオンライン状態確認\n    std::vector<std::string> checkList = {\"player_001\", \"player_004\", \"player_003\", \"player_005\"};\n    \n    std::cout << \"\\nプレイヤーオンライン状態:\\n\";\n    for (const auto& id : checkList)\n    {\n        bool isOnline = activePlayerIDs.find(id) != activePlayerIDs.end();\n        std::cout << \"  \" << id << \": \" << (isOnline ? \"オンライン\" : \"オフライン\") << \"\\n\";\n    }\n    \n    // 4. パフォーマンス比較\n    std::cout << \"\\n=== パフォーマンス比較 ===\\n\";\n    \n    const int testSize = 100000;\n    \n    // テストデータの生成\n    std::vector<std::string> testKeys;\n    testKeys.reserve(testSize);\n    \n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(1000000, 9999999);\n    \n    for (int i = 0; i < testSize; ++i)\n    {\n        testKeys.push_back(\"key_\" + std::to_string(dis(gen)));\n    }\n    \n    // std::map vs std::unordered_map の挿入パフォーマンス\n    std::map<std::string, int> orderedMap;\n    std::unordered_map<std::string, int> unorderedMap;\n    \n    // std::map への挿入時間測定\n    auto start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i < testSize; ++i)\n    {\n        orderedMap[testKeys[i]] = i;\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    auto mapInsertTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n    \n    // std::unordered_map への挿入時間測定\n    start = std::chrono::high_resolution_clock::now();\n    for (int i = 0; i < testSize; ++i)\n    {\n        unorderedMap[testKeys[i]] = i;\n    }\n    end = std::chrono::high_resolution_clock::now();\n    auto unorderedInsertTime = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);\n    \n    std::cout << testSize << \"要素の挿入時間:\\n\";\n    std::cout << \"  std::map: \" << mapInsertTime.count() << \"ms\\n\";\n    std::cout << \"  std::unordered_map: \" << unorderedInsertTime.count() << \"ms\\n\";\n    \n    // 検索パフォーマンステスト\n    const int searchCount = 10000;\n    std::vector<std::string> searchKeys;\n    for (int i = 0; i < searchCount; ++i)\n    {\n        searchKeys.push_back(testKeys[i % testSize]);\n    }\n    \n    // map 検索\n    start = std::chrono::high_resolution_clock::now();\n    int mapFoundCount = 0;\n    for (const auto& key : searchKeys)\n    {\n        if (orderedMap.find(key) != orderedMap.end())\n        {\n            ++mapFoundCount;\n        }\n    }\n    end = std::chrono::high_resolution_clock::now();\n    auto mapSearchTime = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n    \n    // unordered_map 検索\n    start = std::chrono::high_resolution_clock::now();\n    int unorderedFoundCount = 0;\n    for (const auto& key : searchKeys)\n    {\n        if (unorderedMap.find(key) != unorderedMap.end())\n        {\n            ++unorderedFoundCount;\n        }\n    }\n    end = std::chrono::high_resolution_clock::now();\n    auto unorderedSearchTime = std::chrono::duration_cast<std::chrono::microseconds>(end - start);\n    \n    std::cout << \"\\n\" << searchCount << \"回の検索時間:\\n\";\n    std::cout << \"  std::map: \" << mapSearchTime.count() << \"μs (\" << mapFoundCount << \"件発見)\\n\";\n    std::cout << \"  std::unordered_map: \" << unorderedSearchTime.count() << \"μs (\" << unorderedFoundCount << \"件発見)\\n\";\n    \n    // 5. ハッシュテーブル情報の確認\n    std::cout << \"\\n=== ハッシュテーブル情報 ===\\n\";\n    \n    std::unordered_map<std::string, int> hashInfo;\n    for (int i = 0; i < 20; ++i)\n    {\n        hashInfo[\"item_\" + std::to_string(i)] = i;\n    }\n    \n    std::cout << \"バケット情報:\\n\";\n    std::cout << \"  要素数: \" << hashInfo.size() << \"\\n\";\n    std::cout << \"  バケット数: \" << hashInfo.bucket_count() << \"\\n\";\n    std::cout << \"  負荷率: \" << hashInfo.load_factor() << \"\\n\";\n    std::cout << \"  最大負荷率: \" << hashInfo.max_load_factor() << \"\\n\";\n    \n    // バケットの使用状況\n    std::cout << \"\\nバケット使用状況 (最初の10バケット):\\n\";\n    for (size_t i = 0; i < std::min(size_t(10), hashInfo.bucket_count()); ++i)\n    {\n        std::cout << \"  バケット[\" << i << \"]: \" \n                  << hashInfo.bucket_size(i) << \"要素\\n\";\n    }\n    \n    // 6. カスタムハッシュ関数の使用\n    std::cout << \"\\n=== カスタムハッシュ関数 ===\\n\";\n    \n    std::unordered_set<Player, PlayerHash, PlayerEqual> uniquePlayers;\n    \n    uniquePlayers.insert(Player(\"アキラ\", 25, 2500));\n    uniquePlayers.insert(Player(\"ユミ\", 22, 3000));\n    uniquePlayers.insert(Player(\"タロウ\", 20, 1800));\n    uniquePlayers.insert(Player(\"アキラ\", 25, 2500));  // 重複：無視される\n    \n    std::cout << \"ユニークプレイヤー数: \" << uniquePlayers.size() << \"\\n\";\n    \n    // プレイヤー検索\n    Player searchPlayer(\"ユミ\", 22, 3000);\n    if (uniquePlayers.find(searchPlayer) != uniquePlayers.end())\n    {\n        std::cout << \"プレイヤー発見: \" << searchPlayer.name << \"\\n\";\n    }\n    \n    // 7. 実用例：ゲーム内統計システム\n    std::cout << \"\\n=== ゲーム内統計システム ===\\n\";\n    \n    std::unordered_map<std::string, std::unordered_map<std::string, int>> playerStats;\n    \n    // ネストしたマップでプレイヤー統計を管理\n    playerStats[\"勇者アキラ\"][\"敵撃破数\"] = 150;\n    playerStats[\"勇者アキラ\"][\"ダンジョンクリア数\"] = 5;\n    playerStats[\"勇者アキラ\"][\"死亡回数\"] = 3;\n    \n    playerStats[\"魔法使いユミ\"][\"魔法使用回数\"] = 300;\n    playerStats[\"魔法使いユミ\"][\"アイテム作成数\"] = 25;\n    playerStats[\"魔法使いユミ\"][\"死亡回数\"] = 1;\n    \n    // 統計情報の表示\n    for (const auto& [playerName, stats] : playerStats)\n    {\n        std::cout << \"\\n\" << playerName << \"の統計:\\n\";\n        for (const auto& [statName, value] : stats)\n        {\n            std::cout << \"  \" << statName << \": \" << value << \"\\n\";\n        }\n    }\n    \n    // 特定の統計を更新\n    playerStats[\"勇者アキラ\"][\"敵撃破数\"] += 5;\n    std::cout << \"\\n勇者アキラの敵撃破数更新: \" \n              << playerStats[\"勇者アキラ\"][\"敵撃破数\"] << \"\\n\";\n    \n    // 8. メモリ効率の考慮\n    std::cout << \"\\n=== メモリ効率とリハッシュ ===\\n\";\n    \n    std::unordered_map<int, std::string> efficientMap;\n    efficientMap.reserve(1000);  // 事前に容量を確保\n    \n    std::cout << \"reserve後のバケット数: \" << efficientMap.bucket_count() << \"\\n\";\n    \n    // 大量データの挿入\n    for (int i = 0; i < 500; ++i)\n    {\n        efficientMap[i] = \"value_\" + std::to_string(i);\n    }\n    \n    std::cout << \"500要素挿入後:\\n\";\n    std::cout << \"  バケット数: \" << efficientMap.bucket_count() << \"\\n\";\n    std::cout << \"  負荷率: \" << efficientMap.load_factor() << \"\\n\";\n    \n    return 0;\n}\n\n/*\n * まとめ：\n * - unordered_map/setはハッシュテーブルベースで平均O(1)の高速アクセス\n * - 順序を気にしない場合はmap/setより高速\n * - リアルタイムゲームやデータベース検索に最適\n * - カスタムハッシュ関数で独自の型も使用可能\n * - reserve()で事前容量確保により再ハッシュを防げる\n * - 負荷率とバケット情報を監視してパフォーマンスを最適化\n * - 大量データの検索・統計処理で威力を発揮\n */"}]